CloudDrive Worker v7.33 — Production 1.0 Implementation Plan (Option 2)
Date: 2026-02-15
Scope: Cloudflare Workers + D1 + R2 + KV/DO + Queues + Cron
Spec baseline: CloudDrive_Worker_UNIFIED_CONSTITUTIONAL_MASTER_v7.33_REBUILT_FULL.txt

====================================================================
0) HARD FREEZE / NON-GOALS (to prevent infinite scope)
====================================================================
IN-SCOPE (Production 1.0):
- Core domain: folders, cards, assets (R2), collections, collection_members, mounts
- Upload pipeline via upload_sessions FSM
- ACL deterministic model: OWNER > COLLECTION ROLE > DENY
- Soft-delete semantics + purge ordering + safety checks
- Idempotency for ALL writes (POST/PUT/DELETE)
- Optimistic locking (version) for mutable rows
- Audit log append-only
- Rate limiting + standard rate limit headers
- Contract version pinning via request header
- Error contract (error_code enum + contract_version echo)

OUT-OF-SCOPE (explicitly NOT done in 1.0):
- Multi-region strong consistency / active-active replication
- Event sourcing / full replay architecture
- Offline-first sync and conflict-free replicated data types (CRDT)
- Formal verification or theorem-proving

Freeze rule:
- Treat v7.33 as “Spec Freeze”. Only allow patches that unblock implementation
  (missing index, missing error_code, missing transition guard), no new paradigms.

====================================================================
1) DELIVERABLES CHECKLIST (what we will ship)
====================================================================
D1:
- Schema + migrations (forward + rollback) with FK ON DELETE strategies
- Indexes for all hot paths and uniqueness guarantees
- Idempotency table (D1) + TTL enforcement (KV) for 24h window
- version-based optimistic locking for all mutable rows

R2:
- Object write-order invariant: metadata → upload → finalize ACTIVE
- Immutable r2_key (write-once)
- Garbage collection of FAILED/ABANDONED uploads

Workers:
- HTTP router + middleware chain
- Validation layer: ID grammar, mount entity_id grammar, contract header, idempotency
- ACL module (single “one true function”)
- Repository layer with transaction helpers
- Audit logger (append-only)
- Upload session FSM engine + transition guards
- Background jobs (Cron + Queue) for purge/cleanup

Ops:
- Rate limit policy (per-user) + headers
- Logging + correlation id
- Retention policy for audit_log

====================================================================
2) CONTRACT: REQUIRED HEADERS / ENVELOPES
====================================================================
Request headers (mandatory for ALL endpoints):
- X-Contract-Version: "v7.33"  (exact match required)
  - Mismatch ⇒ 426 UPGRADE_REQUIRED
- X-Request-Id: ULID (optional but recommended; if absent, worker generates one)
- Authorization: (your auth scheme)  (must resolve to user_id)

Mutating endpoints only (POST/PUT/PATCH/DELETE):
- X-Idempotency-Key: ULID (required)
  - Same key + same canonical payload hash ⇒ return same response
  - Same key + different hash ⇒ 409 IDEMPOTENCY_CONFLICT

Response error envelope (ALL 4xx/5xx):
{
  "error_code": "<CONST_ENUM>",
  "error_message": "<HumanReadable>",
  "contract_version": "v7.33",
  "request_id": "<ULID>"
}

Rate limit headers (ALL responses, including errors):
- X-RateLimit-Limit
- X-RateLimit-Remaining
- X-RateLimit-Reset

====================================================================
3) ID GRAMMAR (implementation rules)
====================================================================
ULID:
- length = 26
- Crockford base32 uppercase recommended
- MUST NOT contain ':'

Composite entity_id for mount only:
- entity_type = "MOUNT"
- entity_id = "mount:<collection_id>:<folder_id>"
- Exactly 3 tokens; no extra ':' anywhere else

Validation:
- Hard validation in worker (authoritative)
- DB CHECK constraints are best-effort and must not replace API validation

====================================================================
4) D1 SCHEMA REQUIREMENTS (tables + keys + FK policies)
====================================================================
All tables MUST include:
- owner_user_id TEXT NOT NULL  (multi-tenant isolation)
- created_at TEXT NOT NULL (UTC ISO8601 ms)
- updated_at TEXT NOT NULL (UTC ISO8601 ms)
- deleted_at TEXT NULL (soft-delete)

Optimistic lock:
- version INTEGER NOT NULL DEFAULT 1  (for mutable domain rows)

FK policy:
- Default ON DELETE RESTRICT across domain rows
- Allowed CASCADE: upload_session_files → upload_sessions (only)

Minimum indexes (non-exhaustive but required):
- folders(owner_user_id, parent_folder_id, deleted_at)
- cards(owner_user_id, folder_id, deleted_at)
- assets(owner_user_id, card_id, deleted_at)
- collections(owner_user_id, deleted_at)
- collection_members(collection_id, user_id)
- mounts(owner_user_id, collection_id, folder_id, deleted_at)
- upload_sessions(owner_user_id, folder_id, state, deleted_at)
- audit_log(owner_user_id, created_at)

Idempotency:
- idempotency_requests(
    owner_user_id, idem_key, method, path,
    request_hash, response_status, response_body, created_at, expires_at
  )
- Unique index on (owner_user_id, idem_key)

====================================================================
5) ACL: SINGLE SOURCE OF TRUTH (deterministic permission)
====================================================================
Decision function:
effective_perms(user_id, resource):
  if user_id == resource.owner_user_id: return FULL
  else if resource is within a collection share context:
     role = collection_members.role(user_id, collection_id)
     if role in {admin, editor, viewer}:
         return role_capabilities[role] intersect resource_capabilities
  return DENY

Rules:
- Absence of rule = DENY
- No implicit escalation
- All endpoints must call ACL module, never ad-hoc checks

Capabilities (suggested minimal set):
- folder: READ, WRITE, DELETE, LIST_CHILDREN
- card: READ, WRITE, DELETE
- asset: READ, WRITE, DELETE, DOWNLOAD (respect allow_download)
- collection: READ, WRITE, MANAGE_MEMBERS
- mount: READ, WRITE (mount itself is a link; operations map to target folder)

====================================================================
6) UPLOAD PIPELINE (FSM + R2/D1 ordering)
====================================================================
States (example, align to spec’s FSM):
- CREATED
- UPLOADING
- FINALIZING
- ACTIVE
- FAILED
- ABANDONED

Write order invariant:
1) D1: create upload_session row state=CREATED
2) D1: create upload_session_files row(s) (manifest)
3) Client uploads to R2 using issued signed URL / direct upload key
4) Worker finalize: verify R2 object exists & size/hash optional
5) D1: insert asset row (or update asset placeholder) + set session ACTIVE
6) Audit log appended for create/finalize

Failure rules:
- If R2 missing at finalize ⇒ mark FAILED; do not create ACTIVE asset
- Cleanup job purges FAILED/ABANDONED sessions after TTL

R2 key immutability:
- r2_key is write-once at creation; any attempt to update ⇒ 400 IMMUTABLE_FIELD

====================================================================
7) SOFT-DELETE + PURGE (safety proof)
====================================================================
Soft-delete:
- Setting deleted_at != NULL makes object logically non-existent
- Reads MUST filter deleted_at IS NULL (unless admin/recovery mode)

Purge ordering (bottom-up):
upload_session_files
→ upload_sessions
→ assets
→ cards
→ folders
→ mounts
→ collection_members
→ collections

Purge safety checks:
- Before hard-deleting a row, verify no ACTIVE references remain
- RESTRICT FKs will enforce, but application should pre-check to produce
  deterministic error_code (e.g., PURGE_BLOCKED_BY_REFERENCE)

Cron jobs:
- cleanup_upload_sessions: mark ABANDONED if stuck; purge expired FAILED
- purge_deleted_objects: hard delete older than retention window

====================================================================
8) IDEMPOTENCY IMPLEMENTATION (must-have)
====================================================================
Canonical request hash:
- hash(canonical_json_body + method + path + owner_user_id)
- Normalize JSON: sorted keys, stable encoding

Flow:
- On write request: lookup (owner_user_id, idem_key)
  - If not found: create record with request_hash, status=PENDING
  - If found and request_hash differs: 409 IDEMPOTENCY_CONFLICT
  - If found and completed: return stored response immediately
- Execute handler in D1 transaction
- Store response (status + body) in idempotency table
- KV cache for quick lookups; source of truth is D1

TTL:
- 24 hours for idem records; cleanup via cron

====================================================================
9) OPTIMISTIC LOCKING (lost update protection)
====================================================================
For any UPDATE on mutable rows:
UPDATE ... SET ..., version = version + 1
WHERE id = ? AND owner_user_id = ? AND version = ? AND deleted_at IS NULL

If rows_affected == 0:
- return 409 CONFLICT (STALE_VERSION)

====================================================================
10) AUDIT LOG (append-only)
====================================================================
Rules:
- INSERT only (no UPDATE/DELETE except retention purge)
- Record: request_id, actor_user_id, action, entity_type, entity_id, metadata JSON
- entity_id colon rule: only MOUNT composite may contain ':'

Retention:
- Define retention_days (e.g., 90) and version it
- Purge old rows via cron

====================================================================
11) RATE LIMIT (deterministic per user)
====================================================================
Policy (starter):
- 60 req/min/user for read endpoints
- 30 req/min/user for write endpoints
- Burst control via sliding window counters in KV or Durable Object

Headers:
- X-RateLimit-Limit: <limit>
- X-RateLimit-Remaining: <remaining>
- X-RateLimit-Reset: <unix epoch seconds>

On exceed:
- 429 RATE_LIMITED

====================================================================
12) API ROUTE MAP (minimal, production-ready)
====================================================================
Auth:
- GET  /me
Folders:
- POST /folders
- GET  /folders/:id
- GET  /folders/:id/children
- PATCH /folders/:id
- DELETE /folders/:id   (soft-delete)
Cards:
- POST /cards
- GET  /cards/:id
- PATCH /cards/:id
- DELETE /cards/:id     (soft-delete)
Assets:
- POST /upload-sessions
- POST /upload-sessions/:id/files
- POST /upload-sessions/:id/finalize
- GET  /assets/:id
- GET  /assets/:id/download   (honor allow_download)
- DELETE /assets/:id (soft-delete)
Collections:
- POST /collections
- GET  /collections/:id
- PATCH /collections/:id
- DELETE /collections/:id (soft-delete)
Collection members:
- POST /collections/:id/members
- PATCH /collections/:id/members/:user_id
- DELETE /collections/:id/members/:user_id
Mounts:
- POST /mounts
- GET  /mounts/:id
- DELETE /mounts/:id (soft-delete)

Admin/ops (optional, guarded):
- POST /ops/purge   (trigger purge job)
- GET  /ops/health

====================================================================
13) PRODUCTION “TOP 10” TESTS (must pass before launch)
====================================================================
1) ACL deny-by-default: user cannot read others’ folder/card/asset
2) Collection role: viewer read-only, editor write, admin manage members
3) Idempotency: retry same request returns same response; diff payload conflicts
4) Optimistic lock: concurrent PATCH conflicts with 409 STALE_VERSION
5) Soft-delete: deleted objects disappear from reads/listing
6) Purge safety: purge respects ordering and does not violate RESTRICT FKs
7) R2 finalize: missing blob cannot become ACTIVE asset
8) Mount entity_id grammar: only mount composite may contain ':'
9) Error contract: all errors return immutable envelope + correct codes
10) Rate limit: returns correct headers and 429 on exceed

====================================================================
14) IMPLEMENTATION ORDER (what we build first)
====================================================================
Week 1 (core infra):
- Router + middleware (contract header, auth, request_id, rate limit)
- D1 schema + migrations + repo layer + transaction helper
- Error contract enum + helpers
- Idempotency subsystem (D1 + KV)
- Audit logger

Week 2 (domain + ACL):
- ACL module (single entry)
- Folders/cards CRUD (soft-delete + version)
- Collections/members CRUD
- Mounts CRUD + mount composite grammar

Week 3 (assets + upload FSM + jobs):
- upload_sessions endpoints + R2 write order + finalize
- asset endpoints + allow_download
- Cron: cleanup_upload_sessions + purge_deleted_objects
- Full test suite of Top 10

Launch gate:
- All Top 10 tests pass
- Observability: logs contain request_id, actor_user_id, entity info
- Documentation: API route map + error codes + rate limits

====================================================================
END
====================================================================
