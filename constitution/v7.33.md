================================================================ Cloud
Drive Worker – UNIFIED CONSTITUTIONAL MASTER SPEC v7.30 REBUILT FULL
EDITION (FSM PERSISTENCE + INDEX/HARDENING ALIGNMENT)
================================================================

Generated: 2026-02-15T08:46:00Z

This document is a clean rebuild (single-source, no legacy layers). All
invariants are defined exactly once in Part I. All other sections
reference Part I rather than restating rules.

CHANGELOG (v7.29 → v7.30) - ADD: ULID-format CHECK constraints for all
domain ID columns in schema (best-effort), including colon-forbid where
applicable. - CLARIFY: ID grammar contract section added (ULID = 26-char
Crockford Base32 uppercase; ‘:’ forbidden in all non-composite IDs).

CHANGELOG (v7.28 → v7.29) - ADD: entity_id contract hardened: ‘:’ is
forbidden for non-composite IDs; mount composite must be exact and
tokens must be ULIDs. - CLARIFY: audit_log entity_id CHECK constraints
added as best-effort DB enforcement (API validation remains
authoritative). - CLARIFY: All FOREIGN KEY relations declare explicit ON
DELETE behavior (default is RESTRICT unless stated).

================================================================ PART I
– CORE INVARIANTS (IMMUTABLE)
================================================================

1)  ID STRATEGY Domain IDs (frozen):

-   folder_id, card_id, asset_id, collection_id, upload_session_id,
    file_id, log_id MUST be ULID (Crockford Base32, 26 chars, uppercase
    A-Z without I/L/O/U).
-   All non-composite IDs MUST NOT contain ‘:’.
-   audit_log.entity_id is special:
    -   If entity_type != ‘MOUNT’ → entity_id MUST be a non-composite
        ULID and MUST NOT contain ‘:’.
    -   If entity_type == ‘MOUNT’ → entity_id MUST be exactly: mount::
        -   Exactly 2 separators ‘:’ and exactly 3 tokens.
        -   The 2 ID tokens MUST be ULIDs (and therefore MUST NOT
            contain ‘:’).

r2_key constraints (frozen):

-   r2_key MUST be 1..1024 chars.
-   r2_key MUST be URL-safe path segment(s): allowed chars
    [A-Za-z0-9._/-]. r2_key charset (frozen): enforcement is required in
    validation layer; DB CHECK is best-effort only.
-   r2_key MUST NOT start with ‘/’ and MUST NOT contain ‘..’ segments.
-   r2_key MUST NOT contain whitespace or control characters.
-   r2_key MUST be unique in assets and unique per upload session
    manifest.

All primary identifiers MUST be ULID (lexicographically sortable):
collection_id, folder_id, card_id, asset_id, log_id, upload_session_id.
(Internal auth tokens may use UUID; not part of domain IDs.)

2)  SCOPE MODEL Scope is determined ONLY by presence of collection_id:

-   Owner scope: collection_id NOT provided.
-   Collection scope: collection_id provided.

Owner scope rules: - Mounts MUST be ignored. - Collection
membership/roles MUST be ignored. - Collection policies MUST be
ignored. - Visibility condition: viewer_id == owner_id. - deleted_at
MUST be NULL. If collection_id is provided in Owner scope → MUST ignore;
MUST NOT return 400.

3)  VISIBILITY & PERMISSION ORDER (FROZEN)

Default visibility filter (frozen): - All list/search endpoints MUST
default to deleted_at IS NULL. - Mount/member visibility filter
(frozen): * Collection scope queries MUST also require
collections.deleted_at IS NULL, mounts.deleted_at IS NULL, and (if
applicable) membership exists with membership.deleted_at IS NULL. -
include_deleted is allowed only for owner/admin and MUST be explicit. -
Purged entities MUST be physically absent.

Resolution order: 1. Determine scope. 2. Apply scope boundary directly
in SQL WHERE clause. 3. If no row → 404 NOT_FOUND. 4. If row found but
insufficient permission → 403 FORBIDDEN. Global fetch + post-filtering
is forbidden.

4)  EFFECTIVE PERMISSION (FROZEN) Roles: owner > admin > editor >
    viewer. Effective permission in Collection scope: effective =
    membership.role ∩ mounts.access

Access/Role intersection matrix (frozen): - mounts.access=viewer:
viewer→viewer, editor→viewer, admin→viewer - mounts.access=editor:
viewer→viewer, editor→editor, admin→editor - mounts.access=admin:
viewer→viewer, editor→editor, admin→admin Owner override: full R D U C X
(independent of mounts.access).

Owner membership row (frozen): - collections.owner_id is the only
owner. - collection_members MUST NOT store role=‘owner’. - If member_id
== collections.owner_id, role is treated as ‘admin’ for membership
purposes.

effective = membership.role ∩ mounts.access Owner override: full R D U C
X. If collection, mount, or folder is deleted → treat as not visible
(404).

5)  USED_BYTES MODEL (OPERATIONAL SOURCE OF TRUTH) folders.used_bytes is
    authoritative at runtime. APIs MUST NOT compute
    SUM(assets.size_bytes) at read time. All mutations MUST update
    used_bytes atomically inside the same transaction that mutates
    assets rows (commit/delete/restore/purge).

Offline reconciliation ONLY: - Runs outside API path. - Runs inside
transaction. - Writes audit_log action = RECONCILE_USAGE with
before_json/after_json.

6)  UPLOAD FSM (SERVER AUTHORITATIVE, SINGLE VERSION)

upload_session_files timestamps (frozen): - upload_session_files rows
are append-only by default. - If updated_at exists, it MUST be set only
when a row is modified (rare). - Implementations SHOULD prefer immutable
rows and create a new row instead of updating.

Upload manifest audit (frozen): - Any creation of upload_session_files
rows MUST write audit_log action=CREATE entity_type=UPLOAD_SESSION. - If
upload_session_files is modified (e.g., replace list), MUST write
audit_log action=UPDATE.

Upload session audit (frozen): - Any creation of upload_session_files
rows MUST write audit_log action=CREATE entity_type=UPLOAD_SESSION. - If
upload_session_files is modified (e.g., replace list), MUST write
audit_log action=UPDATE.

-   UPLOAD_INIT: audit_log action=CREATE entity_type=UPLOAD_SESSION
    entity_id=upload_session_id.
-   UPLOAD_COMMIT: audit_log action=UPDATE entity_type=UPLOAD_SESSION.
-   UPLOAD_CANCEL: audit_log action=DELETE entity_type=UPLOAD_SESSION
    (soft-delete semantic for session).
-   UPLOAD_EXPIRE: audit_log action=UPDATE entity_type=UPLOAD_SESSION
    (job only).

States: INITIATED | COMMITTED | CANCELED | EXPIRED. EXPIRED origin
(frozen): - EXPIRED can be set ONLY by TTL cleanup job. - API handlers
MUST NOT set status=EXPIRED.

Transitions: - INITIATED → COMMITTED - INITIATED → CANCELED - (any) →
EXPIRED (TTL cleanup job only) UPLOADED state is permanently removed.

Upload init validation (frozen): - Server MUST validate r2_key against
r2_key constraints before creating upload_session_files. - If invalid →
400 VALIDATION.

Commit preconditions: - session.status MUST be INITIATED. - All
referenced R2 objects MUST exist. - size_bytes MUST match metadata. If
missing file → 409 UPLOAD_INCOMPLETE and NO D1 writes.

Commit MUST be idempotent: - If already COMMITTED, return the same
result without double counting used_bytes.

replace_mode semantics (frozen): - replace_mode=0: commit inserts new
assets only. - replace_mode=1: within target folder_id, server MUST
soft-delete all existing non-deleted assets reachable from cards in that
folder before inserting new assets, in the same transaction. used_bytes
MUST be decremented for soft-deleted assets and incremented for new
assets atomically.

Orphaned R2 objects policy (frozen): - Request path MUST NOT delete
newly uploaded R2 objects on failure. - Cleanup occurs via cancel
endpoint and/or periodic job based on TTL.

7)  QUOTA (NO PARTIAL STATE)

quota_limit source (frozen): user_plans.quota_bytes for the owner_id.
Quota MUST be enforced at: - INIT (pre-check) - COMMIT (atomic final
check) Formula: used_bytes + delta <= quota_limit If exceeded → 409
QUOTA_EXCEEDED and full transaction rollback. R2 objects MUST NOT be
deleted in request path.

8)  SEARCH CONSISTENCY (FROZEN) Search MUST:

-   Be ownership-only in Owner scope.

-   Be mount-aware in Collection scope.

-   Deduplicate by card_id. Search dedupe rule (frozen):

-   Dedupe MUST be performed after applying deleted_at filters.

-   If include_deleted=true, dedupe prefers non-deleted row; if all are
    deleted, returns latest deleted.

-   Use keyset pagination only.

-   ORDER BY updated_at DESC, DESC. OFFSET pagination is permanently
    forbidden.

Cursor MUST encode: - updated_at - - scope_hash Cross-scope cursor
replay MUST return 404.

Index support (search):

Tie-breaker ULID (frozen): - collections list: tie_breaker_ulid =
collection_id - collection members list: tie_breaker_ulid = member_id -
mounts list: tie_breaker_ulid = folder_id - folders list:
tie_breaker_ulid = folder_id - folder-scoped cards list:
tie_breaker_ulid = card_id - owner-scope cards search/list:
tie_breaker_ulid = card_id - card-scoped assets list: tie_breaker_ulid =
asset_id - audit log: (created_at DESC, log_id DESC) is the tie-breaker
pair

-   Owner-scope/global search over cards MUST be supported by
    idx_cards_owner_updated.
-   Folder-scoped listings MUST be supported by
    idx_cards_folder_updated.

Cursor Encoding (frozen): - cursor.updated_at = last row updated_at -
cursor.entity_ulid = last row ULID tie-breaker
(folder_id/card_id/asset_id) - cursor.scope_hash = SHA-256 of: -
“owner:” + owner_id (Owner scope), OR - “collection:” + collection_id
(Collection scope) Scope hash MUST be verified on every cursor request;
mismatch MUST return 404.

9)  deleted_by semantics (frozen):

-   deleted_by MUST equal actor_id of the request/job that performed the
    soft-delete.
-   deleted_by MUST be a stable principal identifier (viewer_id /
    service account id), not a display name.
-   Restore MUST clear deleted_by.

Audit JSON canonicalization (guidance): - before_json/after_json SHOULD
be stored as canonical JSON using the same algorithm as cards.content. -
Empty string MUST be rejected; NULL is allowed.

AUDIT LOG INTEGRITY (TRANSACTIONAL) Every mutation MUST: - Execute
inside transaction. - Insert audit_log BEFORE COMMIT. - Rollback entire
transaction if audit insert fails.

audit action/type constraints (frozen): - action MUST be one of: CREATE,
UPDATE, DELETE, RESTORE, PURGE, PURGE_ASSET, RECONCILE_USAGE. - Restore
audit action (frozen): any restore endpoint MUST write action=RESTORE. -
entity_type MUST be one of: FOLDER, CARD, ASSET, COLLECTION, MEMBER,
MOUNT, PLAN, UPLOAD_SESSION. - To extend, new values MUST be added in
MINOR version and documented here.

audit_log id format (frozen): Composite entity_id parsing (frozen): -
ULIDs MUST be 26-char Crockford Base32 uppercase and therefore MUST NOT
contain ‘:’. - audit_log.entity_id MUST NOT contain ‘:’ unless
entity_type=‘MOUNT’. - Mount entity_id format is frozen as: ‘mount::’.
Exactly 2 ‘:’ separators are allowed (the ‘mount:’ prefix colon, plus
one between the two ULIDs). and MUST each be ULIDs (26 chars) and
therefore MUST NOT contain ‘:’. - Parsers MUST split on ‘:’ into exactly
3 tokens: [‘mount’, , ]. - Any extra ‘:’ anywhere in entity_id MUST be
rejected with 400 VALIDATION (do not attempt recovery).

-   log_id MUST be ULID.
-   entity_id MUST be ULID for domain entities
    (folder_id/card_id/asset_id/collection_id/upload_session_id).
-   For composite identifiers (e.g., mounts), entity_id MUST be a stable
    ULID alias field or a deterministic string ‘mount::’ (frozen
    format).

Minimum schema (frozen): log_id (ULID), actor_id, action, entity_type,
entity_id, before_json (nullable), after_json (nullable), created_at
(epoch ms).

10) INVARIANT PRESERVATION CLAUSE Future versions MUST NOT:

-   Alter 404 vs 403 semantics.
-   Reintroduce UPLOADED state.
-   Compute used_bytes via SUM at read time.
-   Move visibility evaluation after permission check.
-   Replace keyset pagination with OFFSET.
-   Remove transaction requirement. Such changes require MAJOR version
    increment.

================================================================
updated_at mutation rule (frozen): - Any mutation that changes a row
MUST set updated_at = now_ms. - Mutations that only read MUST NOT change
updated_at. - For soft-delete/restore, updated_at MUST change.

PART II – ROUTER PIPELINE & ERROR CONTRACT

Pipeline (mandatory): auth → scope/visibility boundary → permission →
transaction (mutations only) → handler → audit → error mapping

Response contract: Success: {“ok”: true, “data”: {…}} Failure: {“ok”:
false, “error”: {“code”:“…”, “message”:“…”}}

HTTP mapping: 401 AUTH_REQUIRED / AUTH_INVALID 403 FORBIDDEN 404
NOT_FOUND 400 VALIDATION 409 CONFLICT / QUOTA_EXCEEDED /
UPLOAD_INCOMPLETE / UPLOAD_SESSION_EXPIRED 500 INTERNAL

================================================================ PART
III – API ENDPOINT SET (CANONICAL)
================================================================

Folders: POST /api/v1/folders GET /api/v1/folders DELETE
/api/v1/folders/:folder_id (soft delete) POST
/api/v1/folders/:folder_id/restore DELETE
/api/v1/folders/:folder_id/purge (hard delete; owner only)

Cards: POST /api/v1/folders/:folder_id/cards GET
/api/v1/folders/:folder_id/cards PATCH /api/v1/cards/:card_id DELETE
/api/v1/cards/:card_id (soft delete) DELETE /api/v1/cards/:card_id/purge
(hard delete; owner only)

Assets: GET /api/v1/cards/:card_id/assets DELETE
/api/v1/assets/:asset_id (soft delete) POST
/api/v1/assets/:asset_id/restore DELETE /api/v1/assets/:asset_id/purge
(hard delete; owner only)

Upload: POST /api/v1/upload/init POST /api/v1/upload/commit POST
/api/v1/upload/cancel

Collections: POST /api/v1/collections GET /api/v1/collections PATCH
/api/v1/collections/:collection_id DELETE
/api/v1/collections/:collection_id

Members: POST /api/v1/collections/:collection_id/members GET
/api/v1/collections/:collection_id/members PATCH
/api/v1/collections/:collection_id/members/:member_id DELETE
/api/v1/collections/:collection_id/members/:member_id (soft delete) POST
/api/v1/collections/:collection_id/members/:member_id/restore (restore)

Mounts: POST /api/v1/collections/:collection_id/mounts GET
/api/v1/collections/:collection_id/mounts DELETE
/api/v1/collections/:collection_id/mounts/:owner_id/:folder_id (soft
delete) POST
/api/v1/collections/:collection_id/mounts/:owner_id/:folder_id/restore
(restore)

Search: GET /api/v1/search

Plan/Usage: GET /api/v1/plan GET /api/v1/usage

================================================================ PART IV
– DATABASE SCHEMA (D1 EXECUTABLE, MINIMUM COMPLETE)
================================================================

All timestamps are Unix epoch milliseconds (INTEGER). All domain IDs are
TEXT storing ULIDs.

PRAGMA foreign_keys = ON;

– user_plans CREATE TABLE IF NOT EXISTS user_plans ( owner_id TEXT
PRIMARY KEY, plan TEXT NOT NULL CHECK (length(plan) > 0), quota_bytes
INTEGER NOT NULL CHECK (quota_bytes >= 0), created_at INTEGER NOT NULL
CHECK (created_at > 0), updated_at INTEGER NOT NULL CHECK (updated_at >=
created_at) );

– folders CREATE TABLE IF NOT EXISTS folders ( owner_id TEXT NOT NULL,
folder_id TEXT NOT NULL CHECK (length(folder_id) = 26 AND
instr(folder_id, ‘:’) = 0 AND folder_id GLOB ’[0-9A-HJKMNP-TV-Z]*’),
name TEXT NOT NULL, used_bytes INTEGER NOT NULL DEFAULT 0 CHECK
(used_bytes >= 0), created_at INTEGER NOT NULL CHECK (created_at > 0),
updated_at INTEGER NOT NULL CHECK (updated_at >= created_at), deleted_at
INTEGER CHECK (deleted_at IS NULL OR deleted_at > 0), purge_at INTEGER,
CHECK (purge_at IS NULL OR deleted_at IS NULL OR purge_at >=
deleted_at), deleted_by TEXT, CHECK (deleted_at IS NULL OR (deleted_by
IS NOT NULL AND length(deleted_by) > 0)), PRIMARY KEY (owner_id,
folder_id) );

– cards CREATE TABLE IF NOT EXISTS cards ( owner_id TEXT NOT NULL,
card_id TEXT NOT NULL CHECK (length(card_id) = 26 AND instr(card_id,
‘:’) = 0 AND card_id GLOB ‘[0-9A-HJKMNP-TV-Z]’), folder_id TEXT NOT NULL
CHECK (length(folder_id) = 26 AND instr(folder_id, ’:’) = 0 AND
folder_id GLOB ’[0-9A-HJKMNP-TV-Z]’), title TEXT NOT NULL, content TEXT
NOT NULL, – canonical JSON string created_at INTEGER NOT NULL CHECK
(created_at > 0), updated_at INTEGER NOT NULL CHECK (updated_at >=
created_at), deleted_at INTEGER CHECK (deleted_at IS NULL OR
deleted_at > 0), purge_at INTEGER, CHECK (purge_at IS NULL OR deleted_at
IS NULL OR purge_at >= deleted_at), deleted_by TEXT, CHECK (deleted_at
IS NULL OR (deleted_by IS NOT NULL AND length(deleted_by) > 0)), PRIMARY
KEY (owner_id, card_id), FOREIGN KEY (owner_id, folder_id) REFERENCES
folders(owner_id, folder_id) ON DELETE RESTRICT );

– assets CREATE TABLE IF NOT EXISTS assets ( owner_id TEXT NOT NULL,
asset_id TEXT NOT NULL CHECK (length(asset_id) = 26 AND instr(asset_id,
‘:’) = 0 AND asset_id GLOB ‘[0-9A-HJKMNP-TV-Z]’), card_id TEXT NOT NULL
CHECK (length(card_id) = 26 AND instr(card_id, ’:’) = 0 AND card_id GLOB
’[0-9A-HJKMNP-TV-Z]’), r2_key TEXT NOT NULL UNIQUE CHECK
(length(r2_key) > 0 AND length(r2_key) <= 1024 AND instr(r2_key, ’ ’) =
0 AND instr(r2_key, char(10)) = 0 AND instr(r2_key, char(13)) = 0 AND
instr(r2_key, char(9)) = 0), filename TEXT NOT NULL, mime TEXT NOT NULL,
size_bytes INTEGER NOT NULL CHECK (size_bytes >= 0), created_at INTEGER
NOT NULL CHECK (created_at > 0), updated_at INTEGER NOT NULL CHECK
(updated_at >= created_at), deleted_at INTEGER CHECK (deleted_at IS NULL
OR deleted_at > 0), purge_at INTEGER, CHECK (purge_at IS NULL OR
deleted_at IS NULL OR purge_at >= deleted_at), deleted_by TEXT, CHECK
(deleted_at IS NULL OR (deleted_by IS NOT NULL AND length(deleted_by) >
0)), PRIMARY KEY (owner_id, asset_id), FOREIGN KEY (owner_id, card_id)
REFERENCES cards(owner_id, card_id) ON DELETE RESTRICT );

– collections CREATE TABLE IF NOT EXISTS collections ( owner_id TEXT NOT
NULL, collection_id TEXT NOT NULL CHECK (length(collection_id) = 26 AND
instr(collection_id, ‘:’) = 0 AND collection_id GLOB
’[0-9A-HJKMNP-TV-Z]*‘), name TEXT NOT NULL, policy_json TEXT NOT NULL
CHECK (length(policy_json) > 0) DEFAULT’{“allow_download”:true}’,
created_at INTEGER NOT NULL CHECK (created_at > 0), updated_at INTEGER
NOT NULL CHECK (updated_at >= created_at), deleted_at INTEGER CHECK
(deleted_at IS NULL OR deleted_at > 0), deleted_by TEXT, CHECK
(deleted_at IS NULL OR (deleted_by IS NOT NULL AND length(deleted_by) >
0)), purge_at INTEGER, CHECK (purge_at IS NULL OR deleted_at IS NULL OR
purge_at >= deleted_at), PRIMARY KEY (owner_id, collection_id) );

– collection_members CREATE TABLE IF NOT EXISTS collection_members (
owner_id TEXT NOT NULL, collection_id TEXT NOT NULL CHECK
(length(collection_id) = 26 AND instr(collection_id, ‘:’) = 0 AND
collection_id GLOB ’[0-9A-HJKMNP-TV-Z]*‘), member_id TEXT NOT NULL, role
TEXT NOT NULL CHECK (role IN (’admin’,‘editor’,‘viewer’)), created_at
INTEGER NOT NULL CHECK (created_at > 0), updated_at INTEGER NOT NULL
CHECK (updated_at >= created_at), deleted_at INTEGER CHECK (deleted_at
IS NULL OR deleted_at > 0), deleted_by TEXT, CHECK (deleted_at IS NULL
OR (deleted_by IS NOT NULL AND length(deleted_by) > 0)), purge_at
INTEGER, CHECK (purge_at IS NULL OR deleted_at IS NULL OR purge_at >=
deleted_at), PRIMARY KEY (owner_id, collection_id, member_id), FOREIGN
KEY (owner_id, collection_id) REFERENCES collections(owner_id,
collection_id) ON DELETE RESTRICT );

– mounts CREATE TABLE IF NOT EXISTS mounts ( owner_id TEXT NOT NULL,
collection_id TEXT NOT NULL CHECK (length(collection_id) = 26 AND
instr(collection_id, ‘:’) = 0 AND collection_id GLOB
‘[0-9A-HJKMNP-TV-Z]’), folder_id TEXT NOT NULL CHECK (length(folder_id)
= 26 AND instr(folder_id, ’:’) = 0 AND folder_id GLOB
’[0-9A-HJKMNP-TV-Z]’), access TEXT NOT NULL CHECK (access IN
(‘admin’,‘editor’,‘viewer’)), – access ceiling: viewer|editor|admin
created_at INTEGER NOT NULL CHECK (created_at > 0), updated_at INTEGER
NOT NULL CHECK (updated_at >= created_at), deleted_at INTEGER CHECK
(deleted_at IS NULL OR deleted_at > 0), deleted_by TEXT, CHECK
(deleted_at IS NULL OR (deleted_by IS NOT NULL AND length(deleted_by) >
0)), purge_at INTEGER, CHECK (purge_at IS NULL OR deleted_at IS NULL OR
purge_at >= deleted_at), PRIMARY KEY (owner_id, collection_id,
folder_id), FOREIGN KEY (owner_id, collection_id) REFERENCES
collections(owner_id, collection_id) ON DELETE RESTRICT, FOREIGN KEY
(owner_id, folder_id) REFERENCES folders(owner_id, folder_id) ON DELETE
RESTRICT );

– upload_sessions (FSM persistence) CREATE TABLE IF NOT EXISTS
upload_sessions ( owner_id TEXT NOT NULL, upload_session_id TEXT NOT
NULL CHECK (length(upload_session_id) = 26 AND instr(upload_session_id,
‘:’) = 0 AND upload_session_id GLOB ‘[0-9A-HJKMNP-TV-Z]’), status TEXT
NOT NULL CHECK (status IN
(’INITIATED’,’COMMITTED’,’CANCELED’,’EXPIRED’)), –
INITIATED|COMMITTED|CANCELED|EXPIRED folder_id TEXT NOT NULL CHECK
(length(folder_id) = 26 AND instr(folder_id, ’:’) = 0 AND folder_id GLOB
’[0-9A-HJKMNP-TV-Z]’), replace_mode INTEGER NOT NULL DEFAULT 0 CHECK
(replace_mode IN (0,1)), total_bytes INTEGER NOT NULL CHECK
(total_bytes >= 0), created_at INTEGER NOT NULL CHECK (created_at > 0),
updated_at INTEGER NOT NULL CHECK (updated_at >= created_at), expires_at
INTEGER NOT NULL, CHECK (expires_at > created_at), committed_at INTEGER,
CHECK (committed_at IS NULL OR committed_at >= created_at), canceled_at
INTEGER, CHECK (canceled_at IS NULL OR canceled_at >= created_at), CHECK
(status != ‘COMMITTED’ OR committed_at IS NOT NULL), CHECK (status !=
‘CANCELED’ OR canceled_at IS NOT NULL), CHECK ((status = ‘COMMITTED’) OR
committed_at IS NULL), CHECK ((status = ‘CANCELED’) OR canceled_at IS
NULL), PRIMARY KEY (owner_id, upload_session_id), FOREIGN KEY (owner_id,
folder_id) REFERENCES folders(owner_id, folder_id) ON DELETE RESTRICT );

– upload_session_files (manifest of objects required for COMMIT) CREATE
TABLE IF NOT EXISTS upload_session_files ( owner_id TEXT NOT NULL,
upload_session_id TEXT NOT NULL CHECK (length(upload_session_id) = 26
AND instr(upload_session_id, ‘:’) = 0 AND upload_session_id GLOB
‘[0-9A-HJKMNP-TV-Z]’), file_id TEXT NOT NULL CHECK (length(file_id) = 26
AND instr(file_id, ’:’) = 0 AND file_id GLOB ’[0-9A-HJKMNP-TV-Z]’), –
ULID per file item (not asset_id yet) – file_id format (frozen): ULID,
26-char Crockford Base32 uppercase.

r2_key TEXT NOT NULL CHECK (length(r2_key) > 0 AND length(r2_key) <=
1024 AND instr(r2_key, ’ ‘) = 0 AND instr(r2_key, char(10)) = 0 AND
instr(r2_key, char(13)) = 0 AND instr(r2_key, char(9)) = 0), filename
TEXT NOT NULL, mime TEXT NOT NULL, size_bytes INTEGER NOT NULL, sha256
TEXT CHECK (sha256 IS NULL OR (length(sha256)=64 AND sha256
GLOB’[0-9a-f]*’)), – optional integrity hint (sha256 format: 64 hex
lowercase) created_at INTEGER NOT NULL CHECK (created_at > 0), PRIMARY
KEY (owner_id, upload_session_id, file_id), FOREIGN KEY (owner_id,
upload_session_id) REFERENCES upload_sessions(owner_id,
upload_session_id) ON DELETE CASCADE );

– audit_log CREATE TABLE IF NOT EXISTS audit_log ( owner_id TEXT NOT
NULL, log_id TEXT NOT NULL CHECK (length(log_id) = 26), actor_id TEXT
NOT NULL, action TEXT NOT NULL CHECK (action IN
(‘CREATE’,‘UPDATE’,‘DELETE’,‘RESTORE’,‘PURGE’,‘PURGE_ASSET’,‘RECONCILE_USAGE’)),
entity_type TEXT NOT NULL CHECK (entity_type IN
(‘FOLDER’,‘CARD’,‘ASSET’,‘COLLECTION’,‘MEMBER’,‘MOUNT’,‘PLAN’,‘UPLOAD_SESSION’)),
entity_id TEXT NOT NULL, – entity_id ‘:’ hardening (best-effort; API
validation remains authoritative) CHECK ((entity_type != ‘MOUNT’ AND
instr(entity_id, ‘:’) = 0) OR (entity_type = ‘MOUNT’ AND
instr(entity_id, ‘:’) > 0)), CHECK ((entity_type != ‘MOUNT’ AND
length(entity_id) = 26) OR (entity_type = ‘MOUNT’ AND length(entity_id)
= 59)), CHECK (entity_type != ‘MOUNT’ OR ( substr(entity_id, 1, 6) =
‘mount:’ AND substr(entity_id, 33, 1) = ‘:’ AND instr(substr(entity_id,
34), ‘:’) = 0 AND instr(substr(entity_id, 7, 26), ‘:’) = 0 AND
instr(substr(entity_id, 34, 26), ‘:’) = 0 )), before_json TEXT,
after_json TEXT, created_at INTEGER NOT NULL CHECK (created_at > 0),
PRIMARY KEY (owner_id, log_id) );

– Keyset indexes (ORDER BY updated_at DESC, DESC) CREATE INDEX IF NOT
EXISTS idx_folders_updated ON folders(owner_id, updated_at DESC,
folder_id DESC);

CREATE INDEX IF NOT EXISTS idx_cards_owner_updated ON cards(owner_id,
updated_at DESC, card_id DESC); CREATE INDEX IF NOT EXISTS
idx_cards_owner_deleted_updated ON cards(owner_id, deleted_at,
updated_at DESC, card_id DESC);

CREATE INDEX IF NOT EXISTS idx_cards_folder_updated ON cards(owner_id,
folder_id, updated_at DESC, card_id DESC);

CREATE INDEX IF NOT EXISTS idx_assets_owner_updated ON assets(owner_id,
updated_at DESC, asset_id DESC); CREATE INDEX IF NOT EXISTS
idx_assets_owner_deleted_updated ON assets(owner_id, deleted_at,
updated_at DESC, asset_id DESC);

CREATE INDEX IF NOT EXISTS idx_assets_card_updated ON assets(owner_id,
card_id, updated_at DESC, asset_id DESC);

CREATE INDEX IF NOT EXISTS idx_mounts_visible ON mounts(owner_id,
collection_id, deleted_at, folder_id);

CREATE INDEX IF NOT EXISTS idx_collection_members_active ON
collection_members(owner_id, collection_id, deleted_at, member_id);

CREATE INDEX IF NOT EXISTS idx_collection_members_by_member ON
collection_members(owner_id, member_id, collection_id);

CREATE INDEX IF NOT EXISTS idx_upload_sessions_status_expires ON
upload_sessions(owner_id, status, expires_at);

CREATE UNIQUE INDEX IF NOT EXISTS idx_upload_session_files_session_r2 ON
upload_session_files(owner_id, upload_session_id, r2_key);

CREATE INDEX IF NOT EXISTS idx_upload_session_files_session ON
upload_session_files(owner_id, upload_session_id);

CREATE INDEX IF NOT EXISTS idx_folders_purge ON folders(owner_id,
deleted_at, purge_at);

CREATE INDEX IF NOT EXISTS idx_cards_purge ON cards(owner_id,
deleted_at, purge_at);

CREATE INDEX IF NOT EXISTS idx_assets_purge ON assets(owner_id,
deleted_at, purge_at);

CREATE INDEX IF NOT EXISTS idx_collections_purge ON
collections(owner_id, deleted_at, purge_at);

CREATE INDEX IF NOT EXISTS idx_mounts_purge ON mounts(owner_id,
deleted_at, purge_at);

CREATE INDEX IF NOT EXISTS idx_collections_owner_updated ON
collections(owner_id, updated_at DESC, collection_id DESC);

CREATE INDEX IF NOT EXISTS idx_collection_members_owner_updated ON
collection_members(owner_id, collection_id, updated_at DESC, member_id
DESC);

CREATE INDEX IF NOT EXISTS idx_mounts_owner_updated ON mounts(owner_id,
collection_id, updated_at DESC, folder_id DESC);

CREATE INDEX IF NOT EXISTS idx_audit_owner_created_at ON
audit_log(owner_id, created_at DESC, log_id);

================================================================ PART V
– HARDENING RULES (DETERMINISTIC ENFORCEMENT)
================================================================

1)  Pagination Index Enforcement All keyset pagination queries MUST have
    supporting composite indexes that match the exact ORDER BY clause:
    (updated_at DESC, DESC). Missing tie-breaker is forbidden. Audit log
    is ordered by (created_at DESC, log_id) and MUST have a matching
    index.

2)  policy_json Forward-Compatibility Unknown keys in
    collections.policy_json MUST be ignored and MUST NOT fail
    validation. Only allow_download is read by permission resolver.
    policy_json canonicalization (guidance):

-   On write, server SHOULD store canonical JSON (stable key order) to
    minimize diffs.
-   Empty string MUST be rejected with 400 VALIDATION. allow_download
    resolver rule (frozen):
-   If policy_json is missing allow_download → default true.
-   allow_download permission matrix (frozen):
    -   Owner: always allowed to download (independent of
        allow_download).
    -   Collection members:
        -   viewer: allow_download=false blocks download URL issuance.
        -   editor/admin: download URL issuance is allowed unless
            explicitly blocked by future policies.
-   If allow_download=false → viewers MUST NOT receive presigned
    download URLs.

3)  Soft-delete vs FK behavior Purge TTL (frozen):

-   Soft-delete sets deleted_at = now_ms and purge_at = now_ms +
    TRASH_TTL_MS.

-   TRASH_TTL_MS default: 7 days.

-   Restore clears deleted_at and purge_at.

-   Purge job deletes rows where purge_at IS NOT NULL AND purge_at <=
    now_ms.

-   Purge job order: assets → cards → folders → mounts →
    collection_members → collections.

-   Purge is idempotent. R2 cleanup on purge (frozen): Purge batching
    (frozen):

-   Purge job MUST process at most PURGE_BATCH_LIMIT rows per run per
    table.

-   PURGE_BATCH_LIMIT default: 500.

-   Purge job MUST be resumable via keyset cursor (purge_at, ).

-   When purging assets rows, purge job MUST attempt to delete
    corresponding R2 objects by r2_key.

-   If R2 delete fails transiently, job MUST retry later; DB delete may
    proceed.

-   Purge job MUST log audit_log action PURGE_ASSET with r2_key in
    after_json.

Soft-delete is implemented via deleted_at/purge_at; FK constraints do
NOT imply cascade delete. Hard deletes happen ONLY via purge
endpoints/jobs.

FK ON DELETE policy (clarified): - All domain FKs MUST declare ON DELETE
explicitly. - Default is ON DELETE RESTRICT to prevent accidental
cascade. - Exception: upload_session_files → upload_sessions MAY use ON
DELETE CASCADE to allow hard-purging sessions without orphan rows.

4)  Invariant Consistency Audit Requirement Any future revision MUST
    pass:

-   No invariant is defined more than once.
-   No rule contradicts Part I.
-   Functional sections reference Part I rather than restating rules.

================================================================ PART VI
– RECONCILIATION CONTRACT
================================================================

Reconcile batching (frozen): - Reconcile job MUST process at most
RECONCILE_BATCH_LIMIT folders per run. - RECONCILE_BATCH_LIMIT default:
500. - Reconcile MUST be resumable using keyset cursor (updated_at,
folder_id) over folders.

Background job MAY run RECONCILE_USAGE: - Compute SUM(size_bytes)
grouped by folder on non-deleted assets. - Compare with
folders.used_bytes. - If mismatch, update folders.used_bytes inside a
transaction. - Insert audit_log action = RECONCILE_USAGE with
before_json/after_json snapshots.

================================================================ PART
VII – ACCEPTANCE CHECKLIST (RELEASE GATE)
================================================================

A)  Data consistency

-   Canonical JSON contract (cards.content): Canonicalization algorithm
    (frozen):

-   Parse JSON to a data structure.

-   Recursively sort all object keys in ascending Unicode codepoint
    order.

-   Serialize with no insignificant whitespace.

-   Arrays preserve order.

-   Numbers/booleans/null remain JSON-native.

    -   All API writes MUST validate content is parseable JSON.
    -   Server MUST store a canonical string form (stable key ordering,
        no trailing spaces).
    -   Read paths MUST return exactly the stored canonical string.
    -   Invalid JSON MUST return 400 VALIDATION.

-   cards.content is always canonical JSON and parseable.

-   folders.used_bytes correct after upload/delete/restore/purge.

-   All writes run with transaction + PRAGMA foreign_keys=ON.

B)  Permission / boundary

-   Outside scope → 404; visible but insufficient → 403.
-   effective = role ∩ access; owner override works.
-   deleted collection/mount/folder breaks visibility (404).

C)  Delete / trash

-   Purge ordering contract (frozen):
    -   Purge MUST delete children before parents (assets → cards →
        folders).
    -   Purge MUST treat already-missing rows as success (idempotent).
    -   Purge MUST insert audit_log with action PURGE.
    -   Purge MUST NOT attempt to recompute used_bytes via SUM on
        request path.
-   Soft delete reflected across views under same owner_id.
-   restore works.
-   purge requires owner role and correct ownership.

D)  Upload FSM

-   Commit idempotency (D1 guard): COMMIT MUST perform a conditional
    update of upload_sessions status using WHERE status=‘INITIATED’. If
    0 rows updated, handler MUST re-read session and return prior
    COMMITTED result (no double counting).

-   init/commit/cancel available.

-   upload_sessions + upload_session_files persist correctly.

-   commit idempotent.

-   replace mode updates used_bytes correctly.

-   missing R2 object yields 409 UPLOAD_INCOMPLETE with NO D1 writes.

E)  Search / pagination

-   keyset stable under inserts.
-   cursor contains scope_hash; cross-scope replay rejected.

F)  Audit

-   every mutation inserts audit_log before commit.
-   audit failure rolls back mutation.

G)  Reconcile

-   reconcile job produces RECONCILE_USAGE audit records.
-   reconcile never runs in request path.

H)  Collections/Members/Mounts pagination
I)  Members/Mounts delete/restore

-   Member DELETE sets deleted_at and updates updated_at; restore clears
    deleted_at and updates updated_at.

-   Mount DELETE sets deleted_at and (optionally) purge_at; restore
    clears deleted_at.

-   Re-adding an existing deleted member via POST MUST behave as restore
    (idempotent).

-   Collections GET uses keyset ORDER BY updated_at DESC, collection_id
    DESC.

-   Members GET uses keyset ORDER BY updated_at DESC, member_id DESC
    scoped by collection_id.

-   Mounts GET uses keyset ORDER BY updated_at DESC, folder_id DESC
    scoped by collection_id.

================================================================ PART
VIII – CONFIG CONSTANTS (FROZEN DEFAULTS)
================================================================

All constants may be overridden by environment/config, but defaults are
frozen here.

-   TRASH_TTL_MS = 7 * 24 * 60 * 60 * 1000 (7 days)
-   PURGE_BATCH_LIMIT = 500
-   RECONCILE_BATCH_LIMIT = 500

Any change to these defaults MUST be documented in MINOR version
changelog.

================================================================ PART IX
– D1/SQLite CHECK CONSTRAINTS (BEST-EFFORT)
================================================================

CHECK constraints are used to prevent obviously-invalid data.
Implementations MUST ALSO enforce all frozen validation rules at the API
layer. If a CHECK is too restrictive for a future change, it MUST be
amended via migration in a MINOR version.

================================================================ END OF
SPECIFICATION v7.29
================================================================

====================================================================
VERSION: v7.31 TYPE: CONSTITUTIONAL HARDENING UPGRADE DATE: 2026-02-15
====================================================================

ADDITIONAL HARDENING (Round 3)

1)  STRICT ENTITY TYPE ENUMERATION

-   entity_type must be one of: FOLDER | CARD | ASSET | COLLECTION |
    MOUNT | UPLOAD_SESSION | FILE
-   Any unknown entity_type → 400 VALIDATION
-   No implicit expansion allowed without version bump.

2)  CONTRACT VERSION PINNING

-   Every API request must include: X-Contract-Version header.
-   If header mismatch → 426 UPGRADE REQUIRED.
-   Prevents silent drift between worker and clients.

3)  FSM TRANSITION TABLE IMMUTABILITY

-   upload_sessions FSM transitions are now declared immutable.
-   Any modification requires:
    -   Minor version bump.
    -   Explicit migration note.
-   Runtime dynamic FSM mutation is prohibited.

4)  R2 KEY IMMUTABILITY GUARANTEE

-   r2_key must be write-once.
-   No update allowed after initial creation.
-   DB UPDATE on r2_key column → REJECTED at application layer.

5)  GLOBAL INVARIANT DECLARATION The following invariants are declared
    constitution-level and cannot be relaxed without MAJOR version bump:

-   Domain IDs are ULID, length 26, no ‘:’
-   Only mount composite may contain ‘:’
-   FK default = ON DELETE RESTRICT
-   Soft-delete is domain rule; DB never cascades domain objects
-   entity_id grammar is immutable

==================================================================== END
OF v7.31 HARDENING PATCH
====================================================================

====================================================================
VERSION: v7.32 TYPE: CONSTITUTIONAL CONSISTENCY & SAFETY UPGRADE DATE:
2026-02-15
====================================================================

ROUND 4 HARDENING — ZERO AMBIGUITY INITIATIVE

1)  SOFT-DELETE FORMAL MODEL

Soft-delete is now formally defined as:

deleted_at IS NOT NULL ⇒ object is logically non-existent

Rules: - All read queries MUST include deleted_at IS NULL unless
explicitly operating in admin/recovery mode. - Foreign key presence does
NOT imply existence if deleted_at != NULL. - Purge process must verify
no ACTIVE FK references before hard delete.

2)  PURGE ORDERING PROOF RULE

Hard delete ordering must follow strict bottom-up hierarchy:

upload_session_files → upload_sessions → assets → cards → folders →
mounts → collection_members → collections

Any deviation requires documented proof of non-referential state.

3)  ACL DETERMINISM GUARANTEE

Effective permission is computed as:

OWNER > COLLECTION ROLE > DEFAULT DENY

Rules: - Owner always has full control. - Collection role can only grant
within defined capability set. - No implicit privilege escalation
allowed. - Absence of rule = DENY.

4)  MIGRATION SAFETY CONTRACT

Every schema change must include:

-   Migration ID
-   Forward SQL
-   Rollback SQL
-   Invariant impact statement

Schema without rollback path → REJECTED.

5)  RESPONSE ERROR CONTRACT

All validation errors must return:

{ “error_code”: “”, “error_message”: “”, “contract_version”: “” }

Error codes are immutable once published.

6)  CLOCK & TIME CONSISTENCY RULE

All timestamps must use:

-   UTC only
-   ISO 8601 format
-   Millisecond precision

Worker must not rely on client-provided time.

7)  CONSTITUTIONAL INVARIANT LOCK

The following invariants are FINAL and cannot be relaxed without MAJOR
version bump:

-   ULID grammar immutable
-   Mount composite grammar immutable
-   FK default ON DELETE RESTRICT
-   Soft-delete semantics immutable
-   ACL deny-by-default immutable
-   R2 key write-once immutable

==================================================================== END
OF v7.32 HARDENING PATCH
====================================================================

====================================================================
VERSION: v7.33 TYPE: CONSTITUTIONAL CONCURRENCY & ISOLATION UPGRADE
DATE: 2026-02-15
====================================================================

ROUND 5 HARDENING — DISTRIBUTED CONSISTENCY MODEL

1) MULTI-TENANT ISOLATION GUARANTEE

Tenant isolation invariant:

Every domain object MUST include owner_user_id. All queries MUST filter
by owner_user_id unless operating under explicit collection-sharing
context.

Cross-tenant access without ACL validation → REJECTED.

No shared global objects allowed without explicit collection mapping.

2) TRANSACTIONAL BOUNDARY RULE

D1 operations affecting multiple domain objects MUST execute within a
single transaction.

Atomicity rule: If any statement fails → entire transaction ROLLBACK.

Partial commit state is prohibited.

3) IDEMPOTENCY KEY CONTRACT

All mutating endpoints (POST/PUT/DELETE) MUST accept:

X-Idempotency-Key header (ULID)

Rules: - Same key + same payload → same response - Same key + different
payload → 409 CONFLICT - Idempotency records TTL = 24h (KV-backed)

Prevents duplicate writes under retry conditions.

4) R2 / D1 CONSISTENCY MODEL

Write order invariant:

1.  Insert metadata row (D1)
2.  Upload blob to R2
3.  Finalize metadata status = ACTIVE

Failure handling: - If R2 upload fails → metadata row marked FAILED -
Cleanup job purges FAILED rows after TTL

No ACTIVE record may exist without confirmed R2 object.

5) AUDIT LOG IMMUTABILITY

audit_log rows are append-only.

Rules: - UPDATE prohibited - DELETE prohibited (except purge policy
older than retention window) - Any mutation attempt → REJECTED

Retention policy must be explicitly versioned.

6) CONCURRENCY CONTROL RULE

Optimistic locking required for mutable domain objects.

Each mutable row must include:

version INTEGER NOT NULL

Update rule: WHERE id=? AND version=? If affected rows = 0 → 409
CONFLICT

Prevents lost update anomaly.

7) RATE LIMIT CONTRACT

Rate limit headers must be returned:

X-RateLimit-Limit X-RateLimit-Remaining X-RateLimit-Reset

Limit enforcement must be deterministic per user.

Burst bypass not allowed.

8) GLOBAL CONSISTENCY INVARIANT (FINAL LOCK)

The following are now constitution-level invariants:

-   Multi-tenant isolation immutable
-   Transaction atomicity mandatory
-   Idempotency mandatory for writes
-   Audit log append-only immutable
-   Optimistic locking mandatory
-   R2/D1 write-order invariant immutable

Any violation requires MAJOR version bump.

==================================================================== END
OF v7.33 HARDENING PATCH
====================================================================
